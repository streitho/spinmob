#summary Setting up the environment and getting started with spinmob.
#labels Featured

= Installing and Running =

1. Install all the packages.

Download and install [http://www.python.org/ python], [http://www.scipy.org scipy and numpy], [http://matplotlib.sourceforge.net matplotlib], and [http://www.wxpython.org wxpython] (telling it to generate the tool scripts during install if possible). If you don't care about long downloads or hard drive space, you can also get all of these packages in the [http://www.enthought.com/ enthought python distribution].

Then, if you have windows, you can use the spinmob windows installer from the downloads page. Otherwise, just make a "spinmob" folder in your [SitePackages python site-packages] directory and stick the source files there. You can either [InstallingFromSource swipe the latest version from google's fancy SVN server] (this is ideal) or get a less-frequently-updated version from the downloads section.

2. [PyShell Start pyshell].

3. From the command line, import spinmob and start playing:
{{{
>>> import spinmob as s
}}}

In all of the following we assuming spinmob is imported as "s".



= A Quick Tutorial =

In general, I tried to design this library so that everything running in the background starts with an underscore, such as "_plotting" or "_numpy". Everything the user (you) should play with does not. So essentially if there's something you want to do, try typing "s." and then navigating through the lists in pyshell to see what's available. There is additional functionality hidden in the underscore libraries but I have not tested these functions. They will make their way back into the main library as time progresses.

== Basic Data Handling ==

By far the most useful part of this project is the databox object. It handles the loading and saving of fairly arbitrary ascii data files, such as those generated by Labview. It can also be used as a place to organize and manipulate whatever data you like.

To see what databoxes can do, it's easiest to just create one and start playing with it. Here is a sample PyShell session showing how to add and access columns of data in databox.

First, create a databox and add a column of data, with the column name 'my_column':

{{{
>>> d = s.data.databox()
>>> d['my_column'] = [1,2,3]
}}}

The names of all the columns are stored in the ordered list d.ckeys. You can see what's available by checking this list:

{{{
>>> d.ckeys
['my_column']
}}}

You can access the data by name or by index:

{{{
>>> d['my_column']
array([1, 2, 3])
>>> d[0]
array([1, 2, 3])
}}}

You can also create columns by index; databox will auto-name them:

{{{
>>> d[1] = [10,20,11.5]
>>> d.ckeys
['my_column', '_column1']
>>> d['_column1']
array([10,20,11.5])
}}}

You can access and overwrite them by index or name interchangeably:

{{{
>>> d[1]
array([10,20,11.5])
>>> d[-1]
array([10,20,11.5])
>>> d[-2]
array([1, 2, 3])
>>> d[0] = d['my_column']/2
>>> d[0]
>>> array([0, 1, 1])
}}}

Heads up! These data columns are just numpy arrays, which follow all the numpy rules about integers.

{{{
>>> d[0] = s.array([1,2,3]) / 2.0
}}}

should fix that. :)

Now the databox has two columns. Try adding some header information:

{{{
>>> d.insert_header('test_header', 32)
>>> d.insert_header('test_header2', [1,"test",45.3])
>>> d.hkeys
['test_header2', 'test_header']
}}}

Similar to columns, a list of header elements are contained in d.hkeys. You can access header elements using the d.h() function.

{{{
>>> d.h('test_header')
32
>>> d.h('ader2')
[1, 'test', 45.299999999999997]
}}}

Notice for headers you just need to specify enough of the string to distinguish it from the others.

== Saving and Loading ==

Now that we have a databox with some data in it, save it to a file:

{{{
>>> d.save_file()
}}}

Open up the file with a text editor and see what it looks like inside. Hopefully this makes sense. For saving and loading it is also possible to change the delimiter: 

{{{
>>> d.delimiter = ','
}}}

for example. By default, the delimiter is the python None object, which means "any white space".

You can also load similarly-formatted data files. Try loading the first one you saved:

{{{
>>> d2 = s.data.load()
>>> d2.hkeys
>>> d2[-1]
}}}

You can also use d.load_file() to load data into an existing databox, and 

{{{
>>> s.data.load_multiple()
}}}

will return an array of databoxes.

The only overall structural rule for data files, really, is that the header has to come first, and the data columns come last:

 * Header lines begin with strings and must come before the data columns.
 * Empty lines are ignored.
 * The first data row must be entirely comprised of numbers.
 * The columns can be different lengths or have placeholders with no data.

Play with it and see what you can get away with. Currently databox prefers equal-length columns, but we're working on that.

== Scripting ==

It is also possible to generate new columns of data using a databox script such as the following.

{{{
>>> d('3*c(1)+cos(c("my_column")/h("test_header"))')
array([ 30.99987793,  60.99951176,  35.49890157])
}}}

This will return 3 times column 1 plus the cosine of "my_column" over header element "test_header".

The scripts are basically python syntax with a few additions. First, the scripts can see all the numpy functions like sin(), cos(), and sqrt(), along with the databox column and header query functions c() and h(). Second, you can write scripts with a new keyword "where", such as

{{{
>>> d('3*a+cos(b) where a=c(1); b=c("my_column")/h("test_header")')
array([ 30.99987793,  60.99951176,  35.49890157])
}}}

which does the same thing. Just make sure not to assign c or h as a variable :).

It might seem silly to have the ability to execute scripts (i.e. why not just do them without the strings?) but they do have a purpose. They can shorten or organize a long expression, and they can be used in other automated scripts such as plotting, discussed below.

== Databox Plotting ==

It is pretty easy to plot from spinmob, either from a databox directly or using one of the canned plot functions. Since spinmob uses matplotlib/pylab to plot, you can also access all of these things by typing "s.pylab."

Databoxes have some plotting capabilities. 

{{{
d.plot(0,1)
d.plot('my_column','_column1')
}}}

will do the same thing, plotting the 0 column on the x-axis, and the 1 column on the y-axis. You can also enter scripts like

{{{
>>> d.plot('c(0)+cos(c(1))', 'h(0)*y + b where y=c(1)*27; b=h("eader2")[2]')
}}}

If you want to plot the same analysis script from many similar data files,

{{{
>>> s.plot.files('c(0)+cos(c(1))', 'h(0)*y + b where y=c(1)*27; b=h("eader2")[2]')
}}}

Is a quick way to get it done. If you have a bunch of files and want to plot one data point per file, this is also possible, with scripts like

{{{
>>> s.plot.files('max(c(0))','h(0)',marker='o')
}}}

Check out the help(d.plot) and help(s.plot.files) to learn about the various options. In fact, use help() on everything.

== General Plotting ==

Under s.plot there are a few other plotting functions I wrote to get things done quickly. It is possible to plot functions in 1d or 2d, data arrays in 1d or 2d, and more. 1d functions are relatively straightforward:

{{{
>>> s.plot.function('sin(x)')
>>> s.plot.function(['sin(x)','5*cos(x*3)','sqrt(x)'], -1, 10)
}}}

It is possible to change the dependent variable using the kwarg 'p'. You can also define your own functions:

{{{
>>> def my_f(x): return x**2
>>> s.plot.function([my_f,'arcsin(x)'])
}}}

Similarly, in 2d

{{{
>>> s.plot.surface_function('sin(x*y)')
}}}

or define your own. surface_function() currently only makes colorplots.

Once you have data plotted, there are a whole mess of functions to tweak these plots (most apply to 1d plots) found in 

{{{
>>> s.plot.tweaks
}}}

Try, for example, manipulate_shown_data() or set_all_line_attributes(). The tweaks are all documented via help(). 

I use tweaks so often I put them directly into the global namespace in my startup script with a line like

{{{
>>> import spinmob as s
>>> st = s.plot.tweaks
}}}


Up next: [RandomUsefulFunctions]